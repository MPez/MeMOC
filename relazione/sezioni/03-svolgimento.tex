%\clearpage
\section{Sviluppo}
Lo sviluppo del codice è stato diviso in due fasi distinte, la prima ha riguardato l'implementazione del modello del problema in \acronimo{cplex}, lo sviluppo degli script \emph{Python} per la generazione delle istanze e l'analisi dei dati, la produzione dei grafici; in un secondo momento ho affrontato la progettazione e lo sviluppo della \tabu per poi integrare il codice prodotto nel processo di automazione precedentemente creato.

Vengono quindi descritte prima le parti principali delle implementazioni degli algoritmi usati; in seguito verranno descritti gli script di utilità creati a supporto dei programmi veri e propri.

\subsection{Cplex}
Per la realizzazione della prima esercitazione, e quindi dell'implementazione del modello fornito mediante le \acronimo{api} di \acronimo{cplex} è stata mantenuta la struttura del codice fornita durante i laboratori, con l'aggiunta di una classe: 

\begin{description}
	\item[\textsc{Pannello}]: classe progettata per rappresentare un'istanza del problema, possiede quindi attributi che indicano il numero di nodi, la matrice dei costi e l'identificativo di ogni nodo;
	\begin{description}
		\item[\textsc{readFile}]: metodo che consente di leggere il file di input e di inizializzare gli attributi dell'oggetto;
	\end{description}
	\item[\textsc{main}]: metodo principale che inizializza \acronimo{cplex} preparando l'ambiente, calcola i tempi di esecuzione e scrive i risultati ottenuti su file;
	\item[\textsc{setupLP}]: metodo che implementa il modello di programmazione matematica del problema; vengono definite prima le variabili presenti e, in seguito, vengono inseriti i vincoli in modo da permettere all'ottimizzatore di risolvere il problema.
\end{description}

\subsection{Tabu Search}
L'implementazione della \tabu ha richiesto una fase di progettazione iniziale dove ho definito classi e metodi da utilizzare, ho cercato di sviluppare un codice il più possibile modulare; ne è scaturita la seguente struttura che per semplicità espositiva non scenderà nei minimi dettagli in quanto il codice allegato è ben documentato:

\begin{description}
	\item[\textsc{Istanza}]: classe che rappresenta un'istanza del problema, possiede come attributi la matrice dei costi e il numero di nodi del problema;
	\begin{description}
		\item[\textsc{readFile}]: metodo usato per leggere i dati del problema da file;
		\item[\textsc{maxCosto}]: metodo che calcola il costo massimo tra due nodi;
		\item[\textsc{minCosto}]: metodo che cerca i due nodi tra i quali inserire a costo minimo un terzo nodo;
	\end{description}
	\item[\textsc{Soluzione}]: classe che rappresenta la soluzione al problema utilizzando la \emph{path representation}, ovvero un vettore con la sequenza di nodi che costituiscono il ciclo di costo minimo.
	\begin{description}
		\item[\textsc{shuffleCosto}]: metodo usato per ottenere una soluzione di partenza casuale;
		\item[\textsc{invertiSequenza}]: metodo usato per invertire una sottosequenza della soluzione compresa tra due nodi;
		\item[\textsc{calcolaCosto}]: metodo usato per calcolare il costo della soluzione corrente;
		\item[\textsc{calcolaCostoVicino}]: metodo usato per calcolare il costo del vicino;
		\item[\textsc{stampa}]: metodo usato per stampare la soluzione corrente;
	\end{description}
	\item[\textsc{Mossa}]: classe che rappresenta una mossa effettuata, indica cioè i nodi iniziale e finale della sottosequenza invertita; possiede come attributi il nodo di partenza e arrivo e il costo della soluzione che si ottiene effettuando la mossa;
	\begin{description}
		\item[\textsc{operator==}]: è stato ridefinito l'operatore di uguaglianza in modo da rendere semplici i confronti tra due mosse;
	\end{description}
	\item[\textsc{Solutore}]: classe che si occupa di risolvere l'istanza del problema ottenendo una soluzione e stampandola su file;
	\begin{description}
		\item[\textsc{istanza}]: riferimento all'istanza corrente;
		\item[\textsc{soluzione}]: riferimento alla soluzione corrente;
		\item[\textsc{tabuList}]: vettore delle mosse tabu;
		\item[\textsc{mosseMigliori}]: insieme delle mosse che portano ai vicini con costo migliore;
		\item[\textsc{tabuSearch}]: metodo principale che risolve il problema dato implementando la metaeuristica \tabu;
		\item[\textsc{startSoluzione}]: metodo che determina la soluzione di partenza del problema;
		\item[\textsc{trovaVicini}]: metodo che effettua la ricerca del vicinato e salva i vicini migliori;
		\item[\textsc{scegliVicino}]: metodo che sceglie il vicino sul quale spostarsi;
		\item[\textsc{controllaMossa}]: metodo che controlla se una mossa è presente nella \emph{tabu list};
		\item[\textsc{inserisciMossaTabu}]: metodo che aggiunge la mossa effettuata alla \emph{tabu list};
	\end{description}
\end{description}

L'implementazione della metaeuristica \tabu, e della ricerca locale di cui fa uso, richiede di effettuare alcune scelte su come rappresentare la soluzione e di conseguenza la definizione del vicinato e delle mosse per spostarsi al suo interno. È necessario inoltre scegliere la strategia di esplorazione dei vicini, la determinazione della soluzione di partenza e le condizioni di terminazione.

Io ho scelto di adottare la \emph{path representation}, come suggerito dalle dispense, un vicinato \emph{2-opt} che consente di avere un vicino per ogni coppia di nodi $i, j$ tali che $i$ precede $j$ nella sequenza centro del vicinato.

Ho scelto, inoltre, di adottare come strategia di esplorazione la \emph{steepest descent} utilizzando però due varianti diverse, in un caso viene scelto il vicino migliore, nell'altro viene scelto casualmente un vicino tra i migliori trovati.

Anche per quanto riguarda la soluzione di partenza ho adottato due tecniche diverse, la prima è la \emph{Farthest Insertion} che crea il ciclo iniziale inserendo i nodi più distanti e continua cercando il nodo più lontano tra quelli non ancora inseriti, aggiungendolo tra due nodi consecutivi per cui è minimo il costo di inserimento.

La condizione di terminazione che ho scelto è basata sul numero massimo di iterazioni dell'algoritmo e non ho implementato alcun criterio di aspirazione in quanto da alcune prove iniziali non mi è sembrato portasse benefici alla mia implementazione.

\subsection{Script \emph{Python}}
\subsubsection{generator.py}
Lo script \script{generator.py} è stato creato per agevolare la generazione di istanze di problemi da risolvere con i due metodi scelti; è stato progettato per essere eseguito con diverse opzioni e parametri in modo da soddisfare tutte le esigenze dell'utente; di seguito viene descritta la struttura principale e le funzionalità fornite:

\begin{description}
	\item[\textsc{Node}]: classe che rappresenta un foro sulla griglia, possiede attributi di posizione $(x, y)$ e un numero identificativo;
	\item[\textsc{Grid}]: classe che rappresenta un pannello sul quale vengono fatti i fori; in pratica è costituito da una griglia a due dimensioni sul quale vengono collocati i nodi.
	\begin{description}
		\item[\textsc{manhattan\_distance}]: metodo utilizzato per calcolare la distanza tra due nodi sulla griglia sfruttando la distanza Manhattan\footnote{\url{http://it.wikipedia.org/wiki/Geometria_del_taxi}};
		\item[\textsc{print\_file}]: metodo che genera due file, uno con la configurazione della griglia e uno con la matrice dei costi per essere letto da \acronimo{CPLEX};
	\end{description}
	\item[\textsc{Generator}]: classe che rappresenta il generatore di istanze, si occupa di creare i nodi e di inserirli nella griglia;
	\begin{description}
		\item[\textsc{crea\_nodi}]: metodo che crea i nodi con tre diverse modalità: distribuzione casuale sulla griglia, distribuzione a cluster con un numero di cluster da 1 a 4 e distribuzione circolare.
	\end{description}
\end{description}

\subsubsection{statistic.py}
Lo script \script{statistic.py} è stato creato per effettuare l'analisi dei dati ottenuti mediante l'esecuzione dei metodi di risoluzione producendo poi le medie e le deviazioni standard per disegnare i grafici.

Lo script possiede un'unica classe che si occupa di svolgere tutto il lavoro:
\begin{description}
	\item[\textsc{Data}]: classe che che legge i risultati, calcola le statistiche sugli stessi e scrive i dati su file;
	\begin{description}
		\item[\textsc{read\_data[\_tabu]}]: metodo che si occupa di leggere i dati da file e calcola medie e deviazioni standard;
		\item[\textsc{write\_data[\_tabu]}]: metodo che si occupa di scrivere le statistiche su file per essere elaborati da \emph{Gnuplot}.
	\end{description}
\end{description}

\subsection{Script \emph{Gnuplot}}
Per la stampa dei grafici riguardanti i tempi di risoluzione e i costi con i relativi confronti tra algoritmi, è stato creato uno script chiamato \script{plot.gnuplot} che ha il compito di produrre i file in formato \acronimo{pdf} che verranno poi aggiunti a questa relazione.

\subsection{Script \emph{Bash}}
\label{sec:bash}
Lo script \emph{Bash} denominato \script{eserc\_lab.sh} è stato creato con il preciso scopo di automatizzare i processi di creazione, elaborazione e stampa dei dati e per fornire all'utente uno strumento per eseguire solo alcune attività in modo mirato.

Di seguito vengono elencate le principali funzioni dello script, vengono tralasciate funzionalità accessorie quali la creazione delle cartelle e file, le impostazioni delle variabili e la rimozione di vecchi risultati:

\begin{description}
	\item[\textsc{crea\_casuali}]: funzione che richiama lo script \script{generator.py} indicando quante istanze creare, quanti nodi, quale dimensione della griglia per generare istanze casuali;
	\item[\textsc{crea\_cluster}]: funzione che richiama lo script \script{generator.py} indicando quante istanze creare, quanti nodi, quale dimensione della griglia e quanti cluster per generare istanze a cluster;
	\item[\textsc{crea\_circolari}]: funzione che richiama lo script \script{generator.py} indicando quante istanze creare, quanti nodi, quale dimensione della griglia per generare istanze circolari;
	\item[\textsc{risolvi\_cplex}]: funzione che richiama il programma \script{cplex} una volta per ogni istanza generata, passando come parametri il nome del file relativo al problema e il numero di problema;
	\item[\textsc{risolvi\_tabu}]: funzione che richiama il programma \script{tabusearch} una volta per ogni istanza casuale generata, passando come parametri il nome del file relativo al problema, il numero di problema, il valore della tabu tenure e il numero massimo di iterazioni da effettuare;
	\item[\textsc{calcola\_statistiche}]: funzione che richiama lo script \script{statistic.py} per l'analisi dei risultati;
	\item[\textsc{crea\_grafici}]: funzione che richiama lo script \script{plot.gnuplot} per la generazione dei grafici.
\end{description}