%\clearpage
\section{Sviluppo}
Lo sviluppo del codice è stato diviso in due fasi distinte, la prima ha riguardato l'implementazione del modello del problema in \acronimo{cplex}, lo sviluppo degli script \emph{Python} per la generazione delle istanze e l'analisi dei dati, la produzione dei grafici; in un secondo momento ho affrontato la progettazione e lo sviluppo della \tabu per poi integrare il codice prodotto nel processo di automazione precedentemente creato.

Per ragioni di semplicità espositiva non verranno analizzati in dettaglio ogni classe e metodo sviluppati, per avere una visione particolareggiata si può ricorrere alla lettura diretta del codice che presenta una documentazione sufficiente a comprenderne il funzionamento.

Vengono quindi descritte prima le parti principali delle implementazioni degli algoritmi usati; in seguito verranno descritti gli script di utilità creati a supporto dei programmi veri e propri.

\subsection{Cplex}
Per la risoluzione del problema ho deciso di adottare il modello di \acronimo{tsp} asimmetrico trasformando il grafo del problema, che per natura sarebbe non orientato, in un grafo orientato, utilizzando due archi con lo stesso peso per ogni spigolo.

Inizialmente ho definito delle variabili intere \eqref{eqn:intere} che rappresentano le unità di flusso trasportate tra due nodi diversi e delle variabili binarie \eqref{eqn:binarie} che identificano l'utilizzo o meno di un arco nella soluzione.
Ho quindi inserito il vincolo di flusso sul nodo di partenza \eqref{eqn:sorgente} e i vincoli di bilanciamento di flusso sui restanti nodi \eqref{eqn:flusso}, i quali indicano che la quantità di flusso entrante deve corrispondere a quella uscente, due serie di vincoli che indicano che deve esistere un solo arco uscente \eqref{eqn:uscente} ed un solo arco entrante \eqref{eqn:entrante} per nodo e infine i vincoli che mettono in relazione le variabili del problema \eqref{eqn:relazione}.

Per la realizzazione della prima esercitazione, e quindi dell'implementazione del modello di programmazione mediante le \acronimo{api} di \acronimo{cplex}, è stata mantenuta la struttura del codice fornita durante i laboratori, con l'aggiunta di una classe.
I file coinvolti sono \script{pannello.h} e \script{pannello.cpp} che rappresentano la nuova classe, \script{cpxmacro.h} che contiene delle macro utili al funzionamento di \acronimo{cplex} e \script{main.cpp}:

\begin{description}
	\item[\textsc{Pannello}]: classe progettata per rappresentare un'istanza del problema, possiede infatti attributi che indicano il numero di nodi, la matrice dei costi e l'identificativo di ogni nodo;
	\begin{description}
		\item[\textsc{readFile}]: metodo che consente di leggere il file di input, che contiene i valori relativi all'istanza generata, e di inizializzare gli attributi dell'oggetto;
	\end{description}
	\item[\textsc{main}]: metodo principale che inizializza \acronimo{cplex} preparando l'ambiente, calcola i tempi di esecuzione e scrive i risultati ottenuti su file;
	\item[\textsc{setupLP}]: metodo che implementa il modello di programmazione matematica del problema; vengono definite prima le variabili presenti e, in seguito, vengono inseriti i vincoli in modo da permettere all'ottimizzatore di risolvere il problema.
\end{description}

\subsection{Tabu Search}
La \tabu è un metodo basato sulla ricerca locale in grado di superare il limite dei minimi locali sfruttando meccanismi di memoria: con tale metodo si cerca di sfruttare la struttura dello spazio di ricerca memorizzando alcune informazioni sulle soluzioni già visitate in modo da orientare la ricerca ed evitare di incappare in cicli.

Per raggiungere l'obiettivo la metaerusitica fa uso di una \emph{tabu list}: struttura dati dove vengono salvate le ultime mosse effettuate; una mossa identifica i cambiamenti apportati alla soluzione corrente per giungere alla prossima soluzione esplorata.
La \emph{tabu list} ha una lunghezza variabile che necessita di essere tarata per ottenere i risultati migliori, il parametro che permette di modificare tale lunghezza viene chiamato \emph{tabu tenure}.

Essendo un metodo di ricerca generico, la \tabu richiede di essere specializzata per risolvere uno specifico problema.
Di seguito vengono elencate le componenti del metodo che necessitano di questa specializzazione:

\begin{description}
\item[\textsc{Soluzione}]: la rappresentazione della soluzione avviene tramite \emph{path representation}, ho usato un vettore che indica in modo sequenziale l'ordine di visita dei nodi nel ciclo hamiltoniano;
\item[\textsc{Vicinato}]: ho scelto di utilizzare un vicinato \emph{2-opt} che consente di avere un vicino per ogni coppia di nodi $i, j$ tali che $i$ precede $j$ nella sequenza centro.
Un vicino si ottiene cambiando la posizione di due nodi e invertendo la sottosequenza compresa tra di essi sulla soluzione corrente;
\item[\textsc{Mosse}]: le mosse \emph{tabu} sono implementate salvando al contrario gli indici dei due nodi scambiati, in modo da impedire di tornare ad una soluzione appena visitata;
\item[\textsc{Strategia esplorazione}]: ho scelto di adottare come strategia di esplorazione la \emph{steepest descent} utilizzando però due varianti diverse, in un caso viene scelto il vicino migliore, nell'altro viene scelto casualmente un vicino tra i migliori $k$ trovati;
\item[\textsc{Soluzione di partenza}]: ho adottato due tecniche diverse, la prima è la \emph{Farthest Insertion} che crea il ciclo iniziale inserendo i nodi più distanti e continua cercando il nodo più lontano tra quelli non ancora inseriti, aggiungendolo tra due nodi consecutivi per cui è minimo il costo di inserimento; la seconda, invece, crea una soluzione casuale usando l'algoritmo \emph{Fisher-Yates shuffle}\footnote{\url{https://en.wikipedia.org/wiki/Fisher\%E2\%80\%93Yates_shuffle}};
\item[\textsc{Condizione di terminazione}]: è basata sul numero massimo di iterazioni dell'algoritmo.
\end{description}

L'implementazione della \tabu ha richiesto una fase di progettazione iniziale dove ho definito classi e metodi da utilizzare, ho cercato di sviluppare un codice il più possibile modulare; ne è scaturita la seguente struttura che per semplicità espositiva non scenderà nei minimi dettagli in quanto il codice allegato è ben documentato:

\begin{description}
	\item[\textsc{Istanza}]: classe che rappresenta un'istanza del problema, possiede come attributi la matrice dei costi e il numero di nodi del problema;
	\begin{description}
		\item[\textsc{readFile}]: metodo usato per leggere i dati del problema da file;
		\item[\textsc{maxCosto}]: metodo che calcola il costo massimo tra due nodi;
		\item[\textsc{minCosto}]: metodo che cerca i due nodi tra i quali inserire a costo minimo un terzo nodo;
	\end{description}
	\item[\textsc{Soluzione}]: classe che rappresenta la soluzione al problema utilizzando la \emph{path representation}, ovvero un vettore con la sequenza di nodi che costituiscono il ciclo di costo minimo.
	\begin{description}
		\item[\textsc{shuffleCosto}]: metodo usato per ottenere una soluzione di partenza casuale;
		\item[\textsc{invertiSequenza}]: metodo usato per invertire una sottosequenza della soluzione compresa tra due nodi;
		\item[\textsc{calcolaCosto}]: metodo usato per calcolare il costo della soluzione corrente;
		\item[\textsc{calcolaCostoVicino}]: metodo usato per calcolare il costo del vicino;
		\item[\textsc{stampa}]: metodo usato per stampare la soluzione corrente;
	\end{description}
	\item[\textsc{Mossa}]: classe che rappresenta una mossa effettuata, indica cioè i nodi iniziale e finale della sottosequenza invertita; possiede come attributi il nodo di partenza e arrivo e il costo della soluzione che si ottiene effettuando la mossa;
	\begin{description}
		\item[\textsc{operator==}]: è stato ridefinito l'operatore di uguaglianza in modo da rendere semplici i confronti tra due mosse;
	\end{description}
	\item[\textsc{Solutore}]: classe che si occupa di risolvere l'istanza del problema ottenendo una soluzione e stampandola su file;
	\begin{description}
		\item[\textsc{istanza}]: riferimento all'istanza corrente;
		\item[\textsc{soluzione}]: riferimento alla soluzione corrente;
		\item[\textsc{tabuList}]: vettore delle mosse tabu;
		\item[\textsc{mosseMigliori}]: insieme delle mosse che portano ai vicini con costo migliore;
		\item[\textsc{tabuSearch}]: metodo principale che risolve il problema dato implementando la metaeuristica \tabu;
		\item[\textsc{startSoluzione}]: metodo che determina la soluzione di partenza del problema;
		\item[\textsc{trovaVicini}]: metodo che effettua la ricerca del vicinato e salva i vicini migliori;
		\item[\textsc{scegliVicino}]: metodo che sceglie il vicino sul quale spostarsi;
		\item[\textsc{controllaMossa}]: metodo che controlla se una mossa è presente nella \emph{tabu list};
		\item[\textsc{inserisciMossaTabu}]: metodo che aggiunge la mossa effettuata alla \emph{tabu list};
	\end{description}
\end{description}





\subsection{Script \emph{Python}}
\subsubsection{generator.py}
Lo script \script{generator.py} è stato creato per agevolare la generazione di istanze di problemi da risolvere con i due metodi scelti; è stato progettato per essere eseguito con diverse opzioni e parametri in modo da soddisfare tutte le esigenze dell'utente; di seguito viene descritta la struttura principale e le funzionalità fornite:

\begin{description}
	\item[\textsc{Node}]: classe che rappresenta un foro sulla griglia, possiede attributi di posizione $(x, y)$ e un numero identificativo;
	\item[\textsc{Grid}]: classe che rappresenta un pannello sul quale vengono fatti i fori; in pratica è costituito da una griglia a due dimensioni sul quale vengono collocati i nodi.
	\begin{description}
		\item[\textsc{manhattan\_distance}]: metodo utilizzato per calcolare la distanza tra due nodi sulla griglia sfruttando la distanza Manhattan\footnote{\url{http://it.wikipedia.org/wiki/Geometria_del_taxi}};
		\item[\textsc{print\_file}]: metodo che genera due file, uno con la configurazione della griglia e uno con la matrice dei costi per essere letto da \acronimo{CPLEX};
	\end{description}
	\item[\textsc{Generator}]: classe che rappresenta il generatore di istanze, si occupa di creare i nodi e di inserirli nella griglia;
	\begin{description}
		\item[\textsc{crea\_nodi}]: metodo che crea i nodi con tre diverse modalità: distribuzione casuale sulla griglia, distribuzione a cluster con un numero di cluster da 1 a 4 e distribuzione circolare.
	\end{description}
\end{description}

\subsubsection{statistic.py}
Lo script \script{statistic.py} è stato creato per effettuare l'analisi dei dati ottenuti mediante l'esecuzione dei metodi di risoluzione producendo poi le medie e le deviazioni standard per disegnare i grafici.

Lo script possiede un'unica classe che si occupa di svolgere tutto il lavoro:
\begin{description}
	\item[\textsc{Data}]: classe che che legge i risultati, calcola le statistiche sugli stessi e scrive i dati su file;
	\begin{description}
		\item[\textsc{read\_data[\_tabu]}]: metodo che si occupa di leggere i dati da file e calcola medie e deviazioni standard;
		\item[\textsc{write\_data[\_tabu]}]: metodo che si occupa di scrivere le statistiche su file per essere elaborati da \emph{Gnuplot}.
	\end{description}
\end{description}

\subsection{Script \emph{Gnuplot}}
Per la stampa dei grafici riguardanti i tempi di risoluzione e i costi con i relativi confronti tra algoritmi, è stato creato uno script chiamato \script{plot.gnuplot} che ha il compito di produrre i file in formato \acronimo{pdf} che verranno poi aggiunti a questa relazione.

\subsection{Script \emph{Bash}}
\label{sec:bash}
Lo script \emph{Bash} denominato \script{eserc\_lab.sh} è stato creato con il preciso scopo di automatizzare i processi di creazione, elaborazione e stampa dei dati e per fornire all'utente uno strumento per eseguire solo alcune attività in modo mirato.

Di seguito vengono elencate le principali funzioni dello script, vengono tralasciate funzionalità accessorie quali la creazione delle cartelle e file, le impostazioni delle variabili e la rimozione di vecchi risultati:

\begin{description}
	\item[\textsc{crea\_casuali}]: funzione che richiama lo script \script{generator.py} indicando quante istanze creare, quanti nodi, quale dimensione della griglia per generare istanze casuali;
	\item[\textsc{crea\_cluster}]: funzione che richiama lo script \script{generator.py} indicando quante istanze creare, quanti nodi, quale dimensione della griglia e quanti cluster per generare istanze a cluster;
	\item[\textsc{crea\_circolari}]: funzione che richiama lo script \script{generator.py} indicando quante istanze creare, quanti nodi, quale dimensione della griglia per generare istanze circolari;
	\item[\textsc{risolvi\_cplex}]: funzione che richiama il programma \script{cplex} una volta per ogni istanza generata, passando come parametri il nome del file relativo al problema e il numero di problema;
	\item[\textsc{risolvi\_tabu}]: funzione che richiama il programma \script{tabusearch} una volta per ogni istanza casuale generata, passando come parametri il nome del file relativo al problema, il numero di problema, il valore della tabu tenure e il numero massimo di iterazioni da effettuare;
	\item[\textsc{calcola\_statistiche}]: funzione che richiama lo script \script{statistic.py} per l'analisi dei risultati;
	\item[\textsc{crea\_grafici}]: funzione che richiama lo script \script{plot.gnuplot} per la generazione dei grafici.
\end{description}